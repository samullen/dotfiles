snippet do
do
	${0:${VISUAL}}
end
endsnippet
snippet put "IO.puts"
IO.puts "${0}"
endsnippet
snippet ins "IO.inspect"
IO.inspect ${0}
endsnippet
snippet insl "IO.inspect with label"
IO.inspect(${0}label: "${1:label}")
endsnippet
snippet if "if .. do .. end"
if ${1} do
	${0:${VISUAL}}
end
endsnippet
snippet if: "if .. do: .."
if ${1:condition}, do: ${0}
endsnippet
snippet ife "if .. do .. else .. end"
if ${1:condition} do
	${2:${VISUAL}}
else
	${0}
end
endsnippet
snippet ife: "if .. do: .. else:"
if ${1:condition}, do: ${2}, else: ${0}
endsnippet
snippet unless "unless .. do .. end"
unless ${1} do
	${0:${VISUAL}}
end
endsnippet
snippet unless: "unless .. do: .."
unless ${1:condition}, do: ${0}
endsnippet
snippet unlesse "unless .. do .. else .. end"
unless ${1:condition} do
	${2:${VISUAL}}
else
	${0}
end
endsnippet
snippet unlesse: "unless .. do: .. else:"
unless ${1:condition}, do: ${2}, else: ${0}
endsnippet
snippet cond
cond do
	${1} ->
	${0:${VISUAL}}
end
endsnippet
snippet case
case ${1} do
	${2} ->
		${0}
end
endsnippet
snippet for
for ${1:item} <- ${2:items} do
	${0}
end
endsnippet
snippet for:
for ${1:item} <- ${2:items}, do: ${0}
endsnippet
snippet fori
for ${1:item} <- ${2:items}, into: ${3} do
	${0}
end
endsnippet
snippet wi
with ${1:item} <- ${2:items} do
	${0}
end
endsnippet
snippet wie
with(
	${1:item} <- ${2:items}
) do
	${3}
else
	${4} ->
		${0}
end
endsnippet
snippet sp
@spec ${1:name}(${2:args}) :: ${3:returns}
endsnippet
snippet op
@opaque ${1:type_name} :: ${2:type}
endsnippet
snippet ty
@type ${1:type_name} :: ${2:type}
endsnippet
snippet typ
@typep ${1:type_name} :: ${2:type}
endsnippet
snippet cb
@callback ${1:name}(${2:args}) :: ${3:returns}
endsnippet
snippet df
def ${1:name}, do: ${2}
endsnippet
snippet def
def ${1:name} do
	${0}
end
endsnippet
snippet defd
@doc """
${1:doc string}
"""
def ${2:name} do
	${0}
end
endsnippet
snippet defsd
@doc """
${1:doc string}
"""
@spec ${2:name} :: ${3:no_return}
def ${2} do
	${0}
end
endsnippet
snippet defim
defimpl ${1:protocol_name}, for: ${2:data_type} do
	${0}
end
endsnippet
snippet defma
defmacro ${1:name} do
	${0}
end
endsnippet
snippet defmo
defmodule ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
	${0}
end
endsnippet
snippet dfp
defp ${1:name}, do: ${2}
endsnippet
snippet defp
defp ${1:name} do
	${0}
end
endsnippet
snippet defpr
defprotocol ${1:name}, [${0:function}]
endsnippet
snippet defr
defrecord ${1:record_name}, ${0:fields}
endsnippet
snippet doc
@doc """
${0}
"""
endsnippet
snippet im
@impl true
endsnippet
snippet docf
@doc false
endsnippet
snippet fn
fn ${1:args} -> ${0} end
endsnippet
snippet mdoc
@moduledoc """
${0}
"""
endsnippet
snippet mdocf
@moduledoc false
endsnippet
snippet rec
receive do
	${1} ->
		${0}
end
endsnippet
snippet req
require ${0:Logger}
endsnippet
snippet imp
import ${0:module_name}
endsnippet
snippet ali
alias ${0:module_name}
endsnippet
snippet test
test "${1:test name}" do
	${0}
end
endsnippet
snippet testc
test "${1:test_name}", ctx do
	${0}
end
endsnippet
snippet testa
test "${1:test_name}", %{${2:arg: arg}} do
	${0}
end
endsnippet
snippet des
describe "${1:test group subject}" do
	${0}
end
endsnippet
snippet exunit
defmodule ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
	use ExUnit.Case, async: true

	${0}
end
endsnippet
snippet try "try .. rescue .. end"
try do
	${1:${VISUAL}}
rescue
	${2} -> ${0}
end
endsnippet
snippet pry
require IEx; IEx.pry
${0}
endsnippet
snippet qu
quote do
	${1}
end
endsnippet
snippet beh
@behaviour ${1:Mix.Task}
${0}
endsnippet
snippet p
|> ${0}
endsnippet
snippet >e "pipe to each"
|> Enum.each(fn ${1} -> ${0} end)
endsnippet
snippet >m "pipe to map"
|> Enum.map(fn ${1} -> ${0} end)
endsnippet
snippet >f "pipe to filter"
|> Enum.filter(fn ${1} -> ${0} end)
endsnippet
snippet >r "pipe to reduce"
|> Enum.reduce(${1:acc}, fn ${2}, ${3:acc} -> ${0} end)
endsnippet
snippet >i "pipe to inspect"
|> IO.inspect
endsnippet
snippet >il "pipe to inspect with label"
|> IO.inspect(label: "${1:label}")
endsnippet
snippet cs
@doc false
def child_spec(${1:_opts}) do
	%{
		id: __MODULE__,
		start: {__MODULE__, :start_link, ${2:[]}},
		restart: ${3::permanent},
		shutdown: ${4:5000},
		type: ${5::worker}
	}
end
endsnippet
snippet genserver "basic genserver structure"
use GenServer

@doc false
def start_link do
	GenServer.start_link(__MODULE__, ${1:Map.new})
end

@impl true
def init(state) do
	{:ok, state}
end
endsnippet
snippet genserver: "basic genserver structure"
use GenServer

@doc false
def start_link, do: GenServer.start_link(__MODULE__, ${1:Map.new})

@impl true
def init(state), do: {:ok, state}
endsnippet
snippet impl
@impl true
def ${1:name} do
	${0}
end
endsnippet
